package d4lcrypto

import (
	"encoding/base64"
	"time"

	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/pkg/errors"
)

// define errors
var (
	ErrTokenSecretEmpty = errors.New("token secret empty")
	ErrTolenNoSecrets   = errors.New("verification failed - no secrets available")
)

// TokenSecret is a key used for the creation and validation of short-living tokens
type TokenSecret struct {
	key []byte
}

// Read sets a secret from string
func (ts *TokenSecret) Read(secretString string) error {
	if secretString == "" {
		return ErrTokenSecretEmpty
	}
	ts.key = []byte(secretString)
	return nil
}

// NewTokenSecretFromString creates a new secret from string
func NewTokenSecretFromString(secretString string) *TokenSecret {
	ts := &TokenSecret{}
	if err := ts.Read(secretString); err != nil {
		return nil
	}
	return ts
}

// TokenSecrets is a set of token secrets used for key rotation
type TokenSecrets []TokenSecret

// Count returns the number of tokens in the set
func (ts TokenSecrets) Count() int {
	return len(ts)
}

// SetCount changes the number of tokens in the set
func (ts *TokenSecrets) SetCount(count int) {
	*ts = (*ts)[:count]
}

// At returns the i'th secret in the set
func (ts *TokenSecrets) At(i int) *TokenSecret {
	return &(*ts)[i]
}

// NewTokenSecrets creates a new token set given the maximal number of secrets allowed to be used in parallel
func NewTokenSecrets(maxCount int) *TokenSecrets {
	var ts TokenSecrets = make([]TokenSecret, 0, maxCount)
	return &ts
}

// NewTokenSecretsFromStrings creates a new token set from a set of secret strings
func NewTokenSecretsFromStrings(secretStrings ...string) *TokenSecrets {
	ts := NewTokenSecrets(len(secretStrings))
	ts.SetCount(len(secretStrings))
	for i, s := range secretStrings {
		err := ts.At(i).Read(s)
		if err != nil {
			return nil
		}
	}
	return ts
}

// Read updates a token set from a set of secret strings
func (ts *TokenSecrets) Read(secretStrings ...string) error {
	ts.SetCount(len(secretStrings))
	for i, s := range secretStrings {
		if err := (*ts)[i].Read(s); err != nil {
			return err
		}
	}
	return nil
}

// NewTokenGenerator creates a new TokenGenerator with default attributes
func NewTokenGenerator(secret *TokenSecret) *TokenGenerator {
	return &TokenGenerator{
		Secret:      secret,
		NonceLength: 32,
		TTLSeconds:  30,
	}
}

// TokenGenerator generates short-living tokens
type TokenGenerator struct {
	Secret      *TokenSecret
	NonceLength int
	TTLSeconds  int
}

// Generate generates a short living token signed and recognized by only this service
func (t *TokenGenerator) Generate() (string, error) {
	nonce, err := GenerateRandomBytes(t.NonceLength)
	if err != nil {
		return "", err
	}

	nowUTC := time.Now().UTC()
	expiresAtUTC := nowUTC.Add(time.Duration(t.TTLSeconds) * time.Second)

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.RegisteredClaims{
		IssuedAt:  jwt.NewNumericDate(nowUTC),
		NotBefore: jwt.NewNumericDate(nowUTC),
		ExpiresAt: jwt.NewNumericDate(expiresAtUTC),
		Subject:   base64.RawStdEncoding.EncodeToString(nonce),
	})

	return token.SignedString(t.Secret.key)
}

// NewTokenValidator creates a new TokenValidator with default attributes
func NewTokenValidator(secrets *TokenSecrets) *TokenValidator {
	return &TokenValidator{
		Secrets: secrets,
	}
}

// TokenValidator validates short-living tokens
type TokenValidator struct {
	Secrets *TokenSecrets
}

// Validate validates tokens generated by Generate()
func (t *TokenValidator) Validate(tokenString string) error {
	err := ErrTolenNoSecrets
	for _, secret := range *t.Secrets {
		key := secret.key
		_, err = jwt.Parse(tokenString, func(_ *jwt.Token) (interface{}, error) {
			return key, nil
		})
		// Exit on first success or on an error different from 'signature invalid'
		if err == nil || err.(*jwt.ValidationError).Errors&jwt.ValidationErrorSignatureInvalid == 0 {
			break
		}
	}
	return err
}
